# ΕΠΕΞΗΓΗΣΗ ΚΩΔΙΚΑ ΓΙΑ ΠΑΡΟΥΣΙΑΣΗ

## 1. ΔΟΜΗ ΤΟΥ PROJECT (ΠΟΥ ΒΡΙΣΚΕΤΑΙ ΤΙ)
* **GlobalState.h / .cpp**: Ο "εγκέφαλος" του παιχνιδιού. Περιέχει τον Γράφο, τη λίστα των αντικειμένων και το game loop.
* **GameObject.h**: Η βασική κλάση (γονέας) και η δομή του Κόμβου (Node).
* **Snake.h / .cpp**: Η λογική του παίκτη (κίνηση στο γράφο, ουρά).
* **Food.h / .cpp**: Το φαγητό που εμφανίζεται σε τυχαίους κόμβους.
* **main.cpp**: Η είσοδος του προγράμματος, ρυθμίζει τα callbacks της SGG.

---

## 2. ΥΛΟΠΟΙΗΣΗ ΜΕ ΓΡΑΦΟ (GRAPH IMPLEMENTATION)
**Ερώτηση:** Πώς υλοποίησες την πίστα/πλέγμα; Είναι πίνακας;
**Απάντηση:** Όχι, είναι Γράφος (Grid Graph).

### Α. Η ΔΟΜΗ ΤΟΥ ΚΟΜΒΟΥ (NODE)
* **Αρχείο:** `GameObject.h` (γραμμές 11-20).
* Έχω φτιάξει ένα `struct Node`.
* Κάθε κόμβος περιέχει συντεταγμένες (x, y) για τη ζωγραφική.
* **ΤΟ ΣΗΜΑΝΤΙΚΟΤΕΡΟ:** Κάθε κόμβος έχει 4 δείκτες (pointers) προς τους γείτονές του: `Node* up, *down, *left, *right`.
* Έτσι επιτυγχάνεται η συνδεσιμότητα.

### Β. ΤΟ ΧΤΙΣΙΜΟ ΤΟΥ ΓΡΑΦΟΥ
* **Αρχείο:** `GlobalState.cpp` -> συνάρτηση `buildGraph()`.
* Δημιουργώ δυναμικά τους κόμβους.
* Συνδέω τους δείκτες κάθε κόμβου με τους γειτονικούς του (π.χ. `curr->right = grid[i+1][j]`).

### Γ. Η ΚΙΝΗΣΗ ΤΟΥ ΦΙΔΙΟΥ ΣΤΟΝ ΓΡΑΦΟ
* **Αρχείο:** `Snake.cpp` -> συνάρτηση `update()`.
* Δεν μεταβάλλω τα x, y pixels για να κουνηθώ.
* Αλλάζω τον δείκτη `m_head_node` ώστε να δείχνει στον επόμενο γείτονα.
* Παράδειγμα: `nextNode = m_head_node->right` (αν πηγαίνω δεξιά).

---

## 3. ΑΝΤΙΚΕΙΜΕΝΟΣΤΡΕΦΗΣ ΠΡΟΓΡΑΜΜΑΤΙΣΜΟΣ (OOP)

### Α. ΚΛΗΡΟΝΟΜΙΚΟΤΗΤΑ (INHERITANCE)
* **Αρχείο:** `GameObject.h` (γραμμή 24).
* Έχω την κλάση `GameObject` ως Abstract Base Class (Αφηρημένη Βασική Κλάση).
* Περιέχει pure virtual συναρτήσεις: `virtual void update() = 0;`.
* **Αρχεία:** `Snake.h` και `Food.h`.
* Οι κλάσεις `Snake` και `Food` κληρονομούν από την `GameObject` (`public GameObject`).
* Υλοποιούν υποχρεωτικά τις `update()` και `draw()`.

### Β. ΠΟΛΥΜΟΡΦΙΣΜΟΣ (POLYMORPHISM)
* **Αρχείο:** `GlobalState.h` (γραμμή 18).
* Χρησιμοποιώ ένα vector με δείκτες στον γονέα: `std::vector<GameObject*> m_objects`.
* Μέσα σε αυτό το vector αποθηκεύω παιδιά (`new Snake()`, `new Food()`).
* **Αρχείο:** `GlobalState.cpp` -> συνάρτηση `update(float ms)`.
* Ο πολυμορφισμός συμβαίνει στη γραμμή: `for (auto* obj : m_objects) obj->update();`.
* Εδώ, το πρόγραμμα αποφασίζει δυναμικά (κατά την εκτέλεση) ποια `update` θα καλέσει (του φιδιού ή του φαγητού), ανάλογα με το τι είναι το αντικείμενο.

---

## 4. ΣΥΓΚΡΟΥΣΕΙΣ (COLLISIONS)
**Ερώτηση:** Πώς ελέγχεις αν το φίδι έφαγε το φαγητό ή χτύπησε τοίχο;

### Α. SNAKE VS FOOD (Σύγκριση Δεικτών)
* **Αρχείο:** `GlobalState.cpp` -> συνάρτηση `update()` (γραμμή 128).
* Δεν μετράω αποστάσεις με pixels.
* Συγκρίνω αν οι δείκτες είναι ίδιοι: `if (snake->getHeadNode() == food->getNode())`.
* Αν δείχνουν στον ίδιο κόμβο μνήμης, τότε υπάρχει σύγκρουση.

### Β. SNAKE VS WALL (Τοίχος)
* **Αρχείο:** `Snake.cpp` -> συνάρτηση `update()`.
* Αν προσπαθήσω να πάω σε κόμβο που δεν υπάρχει (π.χ. `m_head_node->right == nullptr`), σημαίνει ότι βγήκε από τον γράφο.
* Άρα έχουμε Game Over.

### Γ. SNAKE VS SELF (Ουρά)
* **Αρχείο:** `Snake.cpp` -> συνάρτηση `update()`.
* Η ουρά είναι ένα `vector<Node*>`.
* Ελέγχω αν ο `nextNode` υπάρχει μέσα στη λίστα της ουράς.

---

## 5. DESIGN PATTERNS

### SINGLETON PATTERN
* **Αρχείο:** `GlobalState.h`.
* Η κλάση `GlobalState` είναι Singleton.
* Έχει έναν static δείκτη `m_instance`.
* Ο κατασκευαστής είναι `private`, ώστε να μην μπορεί κανείς να φτιάξει 2ο GlobalState.
* Η πρόσβαση γίνεται παντού μέσω της `GlobalState::getInstance()`.

---

## 6. ΒΙΒΛΙΟΘΗΚΗ SGG (Simple Game Graphics)
* **Input:** Χρησιμοποιώ την `graphics::getKeyState` (π.χ. στο Snake.cpp για τα βελάκια).
* **Rendering:**
    * `graphics::drawRect`: Για τους κόμβους και το σώμα του φιδιού.
    * `graphics::drawDisk`: Για το φαγητό και τα μάτια του φιδιού.
    * `graphics::drawText`: Για το σκορ και τα μηνύματα.
    * `graphics::setOrientation`: Στο Snake.cpp, για να περιστρέφω το κεφάλι ανάλογα με την κατεύθυνση.
* **Audio:** `graphics::playSound` (για εφέ) και `playMusic` (για background).
* **Callbacks:** Στο `main.cpp` ορίζω τις `setDrawFunction` και `setUpdateFunction`.
